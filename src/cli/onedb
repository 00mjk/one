#!/usr/bin/env ruby

# -------------------------------------------------------------------------- */
# Copyright 2002-2011, OpenNebula Project Leads (OpenNebula.org)             #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    */
# not use this file except in compliance with the License. You may obtain    */
# a copy of the License at                                                   */
#                                                                            */
# http://www.apache.org/licenses/LICENSE-2.0                                 */
#                                                                            */
# Unless required by applicable law or agreed to in writing, software        */
# distributed under the License is distributed on an "AS IS" BASIS,          */
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   */
# See the License for the specific language governing permissions and        */
# limitations under the License.                                             */
# -------------------------------------------------------------------------- */

# ----------------------------------------------------------------------------
# Set up the environment
# ----------------------------------------------------------------------------

ONE_LOCATION = ENV["ONE_LOCATION"]

if !ONE_LOCATION
    LIB_LOCATION      = "/usr/lib/one"
    RUBY_LIB_LOCATION = LIB_LOCATION + "/ruby"
    VAR_LOCATION      = "/var/lib/one"
    ETC_LOCATION      = "/etc/one"
else
    LIB_LOCATION      = ONE_LOCATION + "/lib"
    RUBY_LIB_LOCATION = LIB_LOCATION + "/ruby"
    VAR_LOCATION      = ONE_LOCATION + "/var"
    ETC_LOCATION      = ONE_LOCATION + "/etc"
end

$: << RUBY_LIB_LOCATION


require 'OpenNebula'
require 'command_parse'

# TODO: Move the Configuration file to OpenNebula ruby lib?
require "#{RUBY_LIB_LOCATION}/cloud/Configuration"

require 'rubygems'
require 'sequel'

class MigratorBase
    attr_reader :db_version
    attr_reader :one_version
    @verbose

    def initialize(db, verbose)
        @db = db
        @verbose = verbose
    end

    def up
        puts "Method up not implemented for version #{@version}"
        return false
    end
end

class OneDBParse < CommandParse

    COMMANDS_HELP=<<-EOT

Description:

TODO

Commands:

TODO

EOT

    def text_commands
        COMMANDS_HELP
    end

    def text_command_name
        "onedb"
    end

end


################################################################################
# Helpers
################################################################################


def read_onedconf()

    config = Configuration.new("#{ETC_LOCATION}/oned.conf")

    if config[:db] == nil
        puts "No DB defined."
        exit -1
    end

    if config[:db]["BACKEND"].upcase.include? "SQLITE"
        @backend = :sqlite

    elsif config[:db]["BACKEND"].upcase.include? "MYSQL"
        @backend = :mysql

        @server  = config[:db]["SERVER"]
        @port    = config[:db]["PORT"]
        @user    = config[:db]["USER"]
        @passwd  = config[:db]["PASSWD"]
        @db_name = config[:db]["DB_NAME"]

        # Check for errors:
        error   = false
        missing = ""

        (error = true; missing = "SERVER" )  if @server  == nil
        (error = true; missing = "PORT"   )  if @port    == nil
        (error = true; missing = "USER"   )  if @user    == nil
        (error = true; missing = "PASSWD" )  if @passwd  == nil
        (error = true; missing = "DB_NAME")  if @db_name == nil

        if error
            puts "MySQL attribute #{missing} not found in " +
                 "#{ETC_LOCATION}/oned.conf"

             exit -1
         end

         # Clean leading and trailing quotes, if any
         @server  = @server [1..-2] if @server [0] == ?"
         @port    = @port   [1..-2] if @port   [0] == ?"
         @user    = @user   [1..-2] if @user   [0] == ?"
         @passwd  = @passwd [1..-2] if @passwd [0] == ?"
         @db_name = @db_name[1..-2] if @db_name[0] == ?"

    else
        puts "Could not load DB configuration from #{ETC_LOCATION}/oned.conf"
        exit -1
    end
end

def backup_db()
    case @backend
    when :sqlite
        bck_file = "#{VAR_LOCATION}/one.db.bck"

        if( File.exists?(bck_file) )
            puts "File #{bck_file} exists, backup aborted."
            exit -1
        end

        FileUtils.cp("#{VAR_LOCATION}/one.db", "#{bck_file}")
        puts "Sqlite database backup stored in #{bck_file}"
        puts "Copy the file back to restore the DB."

    when :mysql
        bck_file = "#{VAR_LOCATION}/mysql_#{@server}_#{@db_name}.sql"

        if( File.exists?(bck_file) )
            puts "File #{bck_file} exists, backup aborted."
            exit -1
        end

        cmd = "mysqldump -u #{@user} -p#{@passwd} -h #{@server} " +
              "-P #{@port} #{@db_name} > #{bck_file}"

        rc = system(cmd)

        if( !rc )
            puts "Unknown error running '#{cmd}'"
            exit -1
        end

        puts "MySQL dump stored in #{bck_file}"
        puts "Read the 'mysqldump' documentation to restore the DB:"
        puts "http://dev.mysql.com/doc/refman/5.6/en/using-mysqldump.html"

    else
        puts "Unknown DB #{@backend}"
        exit -1
    end

    puts ""
end

def connect_db()
    case @backend
    when :sqlite
        @db = Sequel.sqlite("#{VAR_LOCATION}/one.db")

    when :mysql
        @db = Sequel.connect(
            "mysql://#{@user}:#{@passwd}@#{@server}:#{@port}/#{@db_name}")

    else
        puts "Unknown DB #{@backend}"
        exit -1
    end
end

def read_db_version()
    version   = 0
    timestamp = 0
    comment   = ""

    @db.fetch("SELECT version, timestamp, comment FROM db_versioning " +
              "WHERE oid=(SELECT MAX(oid) FROM db_versioning)") do |row|
        version   = row[:version]
        timestamp = row[:timestamp]
        comment   = row[:comment]
    end

    return [version.to_i, timestamp, comment]

rescue
    # If the DB doesn't have db_versioning table, it means it is empty or a 2.x
    # OpenNebula DB
    begin
        # User with ID 0 (oneadmin) always exists
        @db.fetch("SELECT * FROM user_pool WHERE oid=0") do |row|
        end
    rescue
        puts "Database schema does not look to be created by OpenNebula:"
        puts "table user_pool is missing or empty."

        exit -1
    end

    begin
        # Table image_pool is present only in 2.X DBs
        @db.fetch("SELECT * FROM image_pool") do |row|
        end
    rescue
        puts "Database schema looks to be created by OpenNebula 1.X."
        puts "This tool only works with databases created by 2.X versions."

        exit -1
    end

    comment = "Could not read any previous db_versioning data, assuming it is "+
              "an OpenNebula 2.0 or 2.2 DB."

    return [0, 0, comment]
end


################################################################################
################################################################################


onedb_opts = OneDBParse.new([])
onedb_opts.parse(ARGV)
ops = onedb_opts.options

@verbose = ops[:verbose]

command = ARGV.shift

case command
when "upgrade"
    # Check opennebula is not running
    lock_file = "#{VAR_LOCATION}/.lock"
    if File.exists?(lock_file)
        puts "First stop OpenNebula. Lock file found: #{lock_file}"
        exit -1
    end

    # Get DB connection parameters, from oned.conf or command arguments
    read_onedconf()

    # Connect to DB
    connect_db()

    # Read DB's version
    version, timestamp, comment = read_db_version()

    if( @verbose )
        puts "Version read:"
        puts "#{version} : #{comment}"
    end

    puts ""

    # Upgrade, using the scripts in $LIB_LOCATION/onedb/xx.rb

    migrator_version = version + 1
    migrator = nil
    file = "#{LIB_LOCATION}/onedb/#{migrator_version}.rb"

    if File.exists?(file)   # At least one upgrade will be made
        # Make DB backup
        backup_db()
    end

    while File.exists?(file)
        puts "  > Running migrator #{file}" if @verbose

        load(file)
        migrator = Migrator.new(@db, @verbose)
        result = migrator.up

        if( !result )
            puts "Error while upgrading from #{migrator_version-1} to #{migrator.db_version}"
            return -1
        end

        puts "  > Done" if @verbose
        puts ""

        migrator_version += 1
        file = "#{LIB_LOCATION}/onedb/#{migrator_version}.rb"
    end

    # Modify db_versioning table
    if( migrator != nil )
        comment = "Database migrated from #{version} to #{migrator.db_version}"+
                  " (#{migrator.one_version}) by onedb command."

        max_oid = nil
        @db.fetch("SELECT MAX(oid) FROM db_versioning") do |row|
            max_oid = row[:"MAX(oid)"]
        end

        max_oid = 0 if max_oid == nil

        @db.run "INSERT INTO db_versioning (oid, version, timestamp, comment) "+
                "VALUES ("                                                     +
                    "#{max_oid+1}, "                                           +
                    "'#{migrator.db_version}', "                               +
                    "#{Time.new.to_i}, "                                       +
                    "'#{comment}')"

        puts comment
    else
        puts "Database already uses latest version: #{version}"
    end

when "version"
    read_onedconf()
    connect_db()

    version, timestamp, comment = read_db_version()

    if(@verbose)
        puts "Version:   #{version}"

        time = version == 0 ? Time.now : Time.at(timestamp)
        # TODO: UTC or Local time?
        puts "Timestamp: #{time.getgm.strftime("%b %d, %Y %H:%M")}"

        puts "Comment:   #{comment}"
    else
        puts version
    end

else
    onedb_opts.print_help

    exit -1
end


exit 0